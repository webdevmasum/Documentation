
**************************
database:
**************************

    Schema::create('chattings', function (Blueprint $table) {
        $table->id();
        $table->unsignedBigInteger('sender_id');
        $table->unsignedBigInteger('receiver_id');
        $table->text('message');
        $table->timestamps();
        $table->foreign('sender_id')->references('id')->on('users')->onDelete('cascade');
        $table->foreign('receiver_id')->references('id')->on('users')->onDelete('cascade');
    });


**************************
Model:
**************************

    class Chatting extends Model
    {

    protected $fillable = [
            'ride_id',
            'sender_id',
            'receiver_id',
            'message',
            'is_read',
        ];


        protected $casts = [
            'ride_id'     => 'integer',
            'sender_id'   => 'integer',
            'receiver_id' => 'integer',
            'message'     => 'string',
        ];


        public function sender(): \Illuminate\Database\Eloquent\Relations\BelongsTo
        {
            return $this->belongsTo(User::class, 'sender_id');
        }

        public function receiver(): \Illuminate\Database\Eloquent\Relations\BelongsTo
        {
            return $this->belongsTo(User::class, 'receiver_id');
        }

    }



**************************
Route:
**************************

    Route::prefix('chatting')->controller(ChattingController::class)->group(function () {
        Route::get('/',  'index');
        Route::post('/send', 'send');
        Route::get('/conversation/{receiver_id}', 'conversation');
    });

**************************
Controller:
**************************

namespace App\Http\Controllers\API\Chatting;

use App\Events\MessageSent;
use App\Http\Controllers\Controller;
use App\Http\Resources\API\Chatting\SendResource;
use App\Models\Chatting;
use App\Models\User;
use App\Traits\ApiResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Validator;

class ChattingController extends Controller
{

    use ApiResponse;


    public function index()
    {
        try {
            $auth = auth('api')->user();

            if (!$auth) {
                return $this->errorResponse("Authentication failed.", 401);
            }

            // Fetch unique sender and receiver IDs (excluding the authenticated user)
            $uniqueUserIds = Chatting::where('sender_id', $auth->id)
                ->orWhere('receiver_id', $auth->id)
                ->select('sender_id', 'receiver_id')
                ->get()
                ->flatMap(function ($chat) use ($auth) {
                    return array_filter([$chat->sender_id, $chat->receiver_id], function ($id) use ($auth) {
                        return $id != $auth->id;
                    });
                })->unique()->values();

            if ($uniqueUserIds->isEmpty()) {
                return $this->successResponse([], "No messages found", 200);
            }

            // Fetch user details with the latest message
            $users = User::whereIn('id', $uniqueUserIds)
                ->select('id', 'name', 'avatar')
                ->get()
                ->map(function ($user) use ($auth) {
                    $latestMessage = Chatting::where(function ($query) use ($auth, $user) {
                        $query->where('sender_id', $auth->id)->where('receiver_id', $user->id)
                            ->orWhere('sender_id', $user->id)->where('receiver_id', $auth->id);
                    })
                        ->orderBy('created_at', 'desc')
                        ->first();

                    return [
                        'id'             => $user->id,
                        'name'           => $user->name,
                        'avatar'         => $user->avatar,
                        'latest_message' => $latestMessage ? $latestMessage->message : null,
                        'created_at'     => $latestMessage ? $latestMessage->created_at->format('Y-m-d H:i:s') : null,
                    ];
                });

            return $this->successResponse($users, "Chating history retrieved successfully.", 200);
        } catch (\Exception $exception) {
            Log::error('Error retrieving unique users: ' . $exception->getMessage());
            return $this->errorResponse("Failed to retrieve chating history: " . $exception->getMessage(), 500);
        }
    }

    public function conversation($reciver_id)
    {
        $auth = auth('api')->user();

        try {
            $data = Chatting::where(function ($query) use ($auth, $reciver_id) {
                $query->where('sender_id', $auth->id)->where('receiver_id', $reciver_id)
                    ->orWhere('sender_id', $reciver_id)->where('receiver_id', $auth->id);
            })
                ->with(['sender:id,name,avatar', 'receiver:id,name,avatar'])
                ->orderBy('created_at', 'asc')
                ->get();

            if ($data->isEmpty()) {
                return $this->successResponse([], "No conversation found.", 200);
            }

            return $this->successResponse($data, "Conversation retrieved successfully.", 200);
        } catch (\Exception $exception) {
            Log::error('Error retrieving conversation: ' . $exception->getMessage());
            return $this->errorResponse("Failed to retrieve conversation: " . $exception->getMessage(), 500);
        }
    }


        public function send(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'receiver_id' => 'required|exists:users,id',
            'message'     => 'required|string',
        ]);

        if ($validator->fails()) {
            return $this->errorResponse($validator->errors()->first(), 422);
        }

        $validateData = $validator->validated();

        try {
            // get current auth
            $auth = auth('api')->user();

            $message = Chatting::create([
                'sender_id'   => $auth->id,
                'receiver_id' => $validateData['receiver_id'],
                'message'     => $validateData['message'],
            ]);

            // Broadcast event
            broadcast(new MessageSent($message))->toOthers();

            // eager load relations
            $message->load(['sender:id,name,avatar', 'receiver:id,name,avatar']);

            return $this->successResponse(new SendResource($message), "Message sent successfully", 200);
        } catch (\Exception $exception) {
            Log::error('Error sending message: ' . $exception->getMessage());
            return $this->errorResponse("Failed to send message: " . $exception->getMessage(), 500);
        }
    }
}


**************************
Trait:
**************************

<?php

namespace App\Traits;

use Illuminate\Http\Request;

trait ApiResponse
    {
        /**
        * Return a successful response with a message and data.
        */
        public function successResponse($data, $message = "Success", $code = 200)
        {
            return response()->json([
                'success' => true,
                'message' => $message,
                'status_code' => $code,
                'data' => $data
            ], $code);
        }

        /**
        * Generate an error JSON response.
        */
        public function errorResponse($message = "Something went wrong", $code = 400)
        {
            return response()->json([
                'success' => false,
                'message' => $message,
                'status_code' => $code,
                'data' => ''
            ], $code);
        }


        /**
        * Return a paginated response with a message and pagination metadata.
        */
        public function paginateResponse($paginator, $message = "Data fetched successfully", $code = 200)
        {
            $items = $paginator->items();

            if (empty($items)) {
                return response()->json([
                    'success' => true,
                    'message' => 'No data found',
                    'status_code' => 200,
                    'data' => [],
                    'meta' => [
                        'current_page' => $paginator->currentPage(),
                        'last_page' => $paginator->lastPage(),
                        'per_page' => $paginator->perPage(),
                        'total' => $paginator->total(),
                    ]
                ], 200);
            }

            return response()->json([
                'success' => true,
                'message' => $message,
                'status_code' => $code,
                'data' => $items,
                'meta' => [
                    'current_page' => $paginator->currentPage(),
                    'last_page' => $paginator->lastPage(),
                    'per_page' => $paginator->perPage(),
                    'total' => $paginator->total(),
                ]
            ], $code);
        }
    }


**************************
Channel:
**************************

    // chatting
    Broadcast::channel('chatting.{reciever_id}', function ($user, $reciever_id) {
        return (int) $user->id === (int) $reciever_id;
    });


**************************
.env
**************************

// softvencefsd:

REVERB_APP_ID=250884
REVERB_APP_KEY=qaj0frsxyhdqsehyegyy
REVERB_APP_SECRET=vyuyult4tqr7jzhsrgqm
REVERB_HOST="reverb.softvencefsd.xyz"
REVERB_PORT=443
REVERB_SERVER_PORT=8082
REVERB_SCHEME=https


// local:

# REVERB_APP_ID=393873
# REVERB_APP_KEY=ksbvrx8xzeffoo7slcwl
# REVERB_APP_SECRET=4qzsnwr4cfbmjzvibzw5
# REVERB_HOST="localhost"
# REVERB_PORT=8080
# REVERB_SCHEME=http

**************************
Event: App/Events/messageSent:
**************************

<?php

namespace App\Events;

use App\Models\Chatting;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class MessageSent implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;


    public $message;
    /**
     * Create a new event instance.
     */
    public function __construct(Chatting $message)
    {
        $this->message = $message->load(['sender', 'receiver']);
    }

    /**
     * Get the channels the event should broadcast on.
     *
     * @return PrivateChannel
     */
    public function broadcastOn(): PrivateChannel
    {
        return new PrivateChannel('chatting.' . $this->message->receiver_id);
    }


    public function broadcastAs(): string
    {
        return 'message.sent';
    }

}


**************************
resource/js/echo.js
**************************

import Echo from 'laravel-echo';

import Pusher from 'pusher-js';
window.Pusher = Pusher;

window.Echo = new Echo({
    broadcaster: 'reverb',
    key: import.meta.env.VITE_REVERB_APP_KEY,
    wsHost: import.meta.env.VITE_REVERB_HOST,
    wsPort: import.meta.env.VITE_REVERB_PORT ?? 80,
    wssPort: import.meta.env.VITE_REVERB_PORT ?? 443,
    forceTLS: (import.meta.env.VITE_REVERB_SCHEME ?? 'https') === 'https',
    enabledTransports: ['ws', 'wss'],
});


console.log('Echo initialized with Reverb');

// window.Echo.private('chating.' + 1)
//     .listen('.message.sent', (e) => {
//         console.log('New message:', e.message);
//     });


let recieverId = 1;
window.Echo.private('chatting.' + recieverId)
    .listen('.message.sent', (e) => {
        console.log('New message:', e.message);
    });



**************************
Vite Install: command
**************************
// use for admin dashboard checking

* npm run build
* npm run dev
* console
* web socket
* all->auth-> request url


<head>

    <meta charset="utf-8" />
    <title>@yield('title')</title>

    {!! ToastMagic::styles() !!}

    @include('backend.partials.styles')
    //vite
    @vite(['resources/css/app.css', 'resources/js/app.js']) 

</head>

**************************
bootstrap/app.php
**************************

<?php

use Illuminate\Foundation\Application;
use Illuminate\Foundation\Configuration\Exceptions;
use Illuminate\Foundation\Configuration\Middleware;
use Illuminate\Support\Facades\Route;
use App\Helpers\Helper;
use Illuminate\Auth\Access\AuthorizationException;
use Illuminate\Auth\AuthenticationException;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Illuminate\Http\Request;
use Illuminate\Validation\ValidationException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__ . '/../routes/web.php',
        commands: __DIR__ . '/../routes/console.php',
        channels: __DIR__ . '/../routes/channels.php',
        health: '/up',
        then: function () {
            Route::middleware(['web', 'admin'])
                ->group(base_path('routes/backend.php'));
            Route::middleware(['web'])
                ->group(base_path('routes/backend_cms.php'));
            Route::middleware(['api'])
                ->prefix('api')
                ->group(base_path('routes/api.php'));
        }
    )
    ->withBroadcasting(
        __DIR__ . '/../routes/channels.php',
        ['prefix' => 'api', 'middleware' => ['auth:api']],
    )
    ->withMiddleware(function (Middleware $middleware) {
        $middleware->alias([
            'admin' => \App\Http\Middleware\AdminMiddleware::class,
        ]);
    })
    ->withExceptions(function (Exceptions $exceptions) {
        $exceptions->render(function (Throwable $e, Request $request) {
            if ($request->is('api/*')) {
                if ($e instanceof ValidationException) {
                    return response()->json([
                        'message' => $e->getMessage(),
                        'errors'  => $e->errors(),
                    ], 422);
                }

                if ($e instanceof ModelNotFoundException) {
                    return response()->json([
                        'message' => 'Resource not found',
                    ], 404);
                }

                if ($e instanceof AuthenticationException) {
                    return response()->json([
                        'message' => $e->getMessage(),
                    ], 401);
                }
                if ($e instanceof AuthorizationException) {
                    return response()->json([
                        'message' => $e->getMessage(),
                    ], 403);
                }
               // Dynamically determine the status code if available
                $statusCode = method_exists($e, 'getStatusCode') ? $e->getStatusCode() : 500;

                return response()->json([
                    'message' => $e->getMessage(),
                ], $statusCode);
            } else {
                return null;
            }
        });
    })->create();




**************************
Flutter credentials
**************************

***->   https://browgod.softvencefsd.xyz/api/broadcasting/auth
***->   env.
***->   event
***->   
***->

**************************
Flutter credentials
**************************























